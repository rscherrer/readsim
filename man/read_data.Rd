% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/read_data.R
\name{read_data}
\alias{read_data}
\title{Read simulation data}
\usage{
read_data(
  dir,
  variables,
  split = 1L,
  dupl = 1L,
  type = "numeric",
  size = 8L,
  sep = "_",
  is_tbl = TRUE,
  ext = ".dat",
  byrow = TRUE
)
}
\arguments{
\item{dir}{Path to the simulation folder}

\item{variables}{Names of variables to read (e.g. \code{c("time",
"popsize")}), with no file extension (i.e. not \code{"time.dat"})}

\item{split}{Vector of srictly positive integers specifying in how many
columns to split each variable (one value per input variable). Note that
\code{0} is not an accepted value. If \code{split} is a vector of length 1, it will
be recycled to the length of \code{variables}.}

\item{dupl}{Either a vector of strictly positive integers specifying
how many times to duplicate each value of each variable (one value per input
variable), or a list of vectors of strictly positive integers specifying
how many times to duplicate each value of each variable (one vector per
input variable). If \code{dupl} is of length 1, it will be recycled to the
length of \code{variables}. If \code{dupl} is a vector, then the value \code{0}
is not allowed. If \code{dupl} is a list, then each vector must either be
of the same length as its corresponding variable to be read, or of length 1,
in which case it will be recycled to the length of the variable.}

\item{type}{Type of the data to read. Default is \code{"numeric"} but can
also be \code{"integer"} or \code{"logical"}.}

\item{size}{Size of the values to read. Default is \code{8} bytes
(size of a double-precision floating point number on most 64-bit systems).
Make sure to set this to the correct size for the data type you are reading
into (e.g. \code{numeric} are often of size \code{8}, \code{integer} of size \code{4},
and \code{logical} can be of size \code{1}). It is assumed that the size of the
values saved into the file is known a priori.}

\item{sep}{Separator to use for column names when columns are split.
Default is \code{"_"}.}

\item{is_tbl}{Logical. If \code{TRUE}, the result is a tibble.
If \code{FALSE}, the result is a data frame. Default is \code{TRUE}.}

\item{ext}{File extension of the data files. Default is \code{".dat"}.
Can be a vector if each variable has its own extension. In that case,
\code{ext} must be of the same length as \code{variables}.}

\item{byrow}{Logical. If \code{TRUE}, the data is fllled into columns
by row, otherwise, by column. This should only matter if \code{split} is
greater than 1.}
}
\value{
A data frame (or tibble) containing the combined data
}
\description{
Combine data from one simulation into a single tibble.
}
\details{
Each variable is read from its respective file into a vector of
values. Then, each value of each vector is duplicated a number of times
specified by \code{dupl}, and the resulting vector is split into a number of
columns specified by \code{split}. The result is one data frame per
variable. The data frames are then combined into a single data frame by
column, provided that they have the same number of rows (there will be an
error otherwise, so \code{split} and \code{dupl} must be chosen wisely).
}
\note{
The data must be saved in \strong{binary format}, with extension
\code{.dat}. See package documentation for details.
}
\examples{

# Path to a simulation
path <- system.file("extdata", "example", package = "readsim")

# Read one variable
read_data(path, "time")

# Read two columns with the same dimensions
read_data(path, c("time", "popsize"))

# Read two variables but split one into many columns
read_data(path, c("time", "patchsizes"), split = c(1, 10))

# Read two variables but duplicate one to match the other
read_data(path, c("time", "patchsizes"), dupl = c(10, 1))

}
